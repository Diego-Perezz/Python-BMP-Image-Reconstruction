# explore.py
import string

messages = [
    'Hpwnzxp ez esp ajeszytn ufyrwp! Hp slgp opepnepo l atpnp zq plces qcfte ty jzfc alnv. Estd td olyrpczfd ez esp Ajeszytn Ufyrwp pygtczyxpye. Awpldp cpxzgp te ez nzyetyfp.',
    'Hpwnzxp ez esp Ajeszytn Ufyrwp! Nzyetyfp jzfc piawzcletzy mj clqetyr lnnczdd esp ctgpc.',
    ]

pack = {'raft': {'origin': 'pythonic', 'length': 2, 'width': 3},
        'apple': {'origin': 'earth', 'size': 0.25, 'density': 0.8}}

### Additional Functions ##############

# Your code goes here.


# function generated by a LLM...  https://chatgpt.com/share/679fd4fd-c810-8003-942a-f43e0c05fbf9

def caesar_cipher_decrypt(message):
  """
  Displays all possible Caesar Cipher decryptions (shifts) 
  of a given message and returns the user-selected decryption.

  Args:
    encrypted message 

  Returns: 
    decrypted message 
  """
  alphabet = string.ascii_lowercase  # 'abcdefghijklmnopqrstuvwxyz'
  possible_decryptions = {}

  print("\nAll possible shifts:")
  for shift in range(1, 26):  # Iterate through shifts 1 to 25
      decrypted_message = ""
      for char in message:
          if char.isalpha():  # Only shift letters
              is_upper = char.isupper()
              char_lower = char.lower()
              
              # Shift character and handle wrap-around
              new_index = (alphabet.index(char_lower) - shift) % 26
              new_char = alphabet[new_index]
              
              decrypted_message += new_char.upper() if is_upper else new_char
          else:
              decrypted_message += char  # Keep non-alphabetic characters unchanged
      
      possible_decryptions[shift] = decrypted_message
      print(f"\nShift {shift}: {decrypted_message}")

  #Let the user choose the correct shift
  while True:
      try:
          user_choice = int(input("\nEnter the correct shift number (1-25): "))
          if 1 <= user_choice <= 25:
              return possible_decryptions[user_choice]
          else:
              print("Invalid choice! Please enter a number between 1 and 25.")
      except ValueError:
          print("Invalid input! Please enter a valid number.")



# Iterate over multiple messages
for i, message in enumerate(messages, start=1):
    print(f"\nMessage {i} of {len(messages)}: ")
    decrypted_text = caesar_cipher_decrypt(message)
    print(f"\nFinal Decrypted Message {i}: \n{decrypted_text}\n")

    # Pause before showing the next messages 
    if i < len(messages):  # Only pause if there's another message left
        input("\nPress Enter to continue to the next message...")

print("All Messages Decoded!\n")


#######################################

def check_pack(pack):
  '''
  pack is a dictionary with tools for exploring the pythonic jungle
  returns False if any earth fruit is contained in the pack.
  (Note: This is important for environmental stability.)
  '''

  # deletes the apple item to fix the pack 
  del pack['apple'] 

  for item in pack.values():
    if item.get('origin') == 'earth':
      return False
  return True


  



def cross_river(raft):
  '''
  raft is an object with properties for the raft.
  returns True if the raft can cross the river.
  '''

  # modifies the raft dimensions for it to be able to cross the river
  pack['raft']['width'] = 5
  pack['raft']['length'] = 5

  length = raft.get('length')
  width = raft.get('width')
  depth = 1
  volume = length*width*depth
  density = 0.5
  p_water, gravity = 1, 10
  minimum_volume = 100/((p_water-density)*gravity)

  if length <= 0.0 or width <= 0.0:
    return False
  elif length < 2 or width < 2:
    return False
  elif length > 10 or width > 10:
    return False
  elif volume < minimum_volume:
    return False
  else:
    return True



while True:
  if check_pack(pack):
    print("Welcome to the Pythonic Jungle! Continue your exploration by rafting accross the river.")
    print(cross_river(pack.get('raft')))
  else:
    print(messages[0])
  break

